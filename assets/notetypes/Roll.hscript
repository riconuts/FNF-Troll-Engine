function setupNote(note:Note){
    note.maxReleaseTime = 0.5;
    note.isRoll = true;
    if(note.isSustainNote){
        note.texture = 'ROLL_assets';
        note.noAnimation = true;
    }
}

function loadNoteAnims(note){
    var prefix = Note.colArray[note.column];
    
	var animName = '';
    if(note.isQuant){
		if(note.holdType == 1)
			animName = 'quant roll piece';
		else if(note.holdType == 2)
			animName = 'quant roll end';
		
        note.animation.addByPrefix(prefix + 'holdend', 'quant roll end');
    }else{
		if(note.holdType == 1)
			animName = prefix + ' roll piece';
		else if(note.holdType == 2)
			animName = prefix + ' roll end';
    }
	note.animation.addByPrefix('default', animName);
	note.animation.play('default', true);
    note.scale.set(1.5, 0.7);
	note.updateHitbox();

}

function onHoldPress(note, field){
    note.tripProgress = 1;

    var chars = game.getNoteCharacters(note, field);
    var animToPlay = field.singAnimations[note.column] + note.characterHitAnimSuffix;

    // play the intended singing animation when the player presses the roll, and prevent the character from going back to idle
	for (char in chars) 
    {
		char.playAnim(animToPlay, true);
        char.skipDance = true;
    }

    // allow the character to go back to their idle animation when the roll is either finished or dropped
    for(func in [field.holdFinished, field.holdDropped]) {
        func.add(() ->
        {
            for (char in chars) 
            {
                char.skipDance = false;
                char.holdTimer = 0.0;
            }
        });
    }
}